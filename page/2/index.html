<!DOCTYPE html><html lang="zh-cn"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content><meta name="keywords" content><meta name="author" content="Conglei Xu"><meta name="copyright" content="Conglei Xu"><title>Understanding the infinite world within a finite life. | Conglei Xu</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script><!-- hexo-inject:begin --><!-- hexo-inject:end -->var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  }
} </script><!-- hexo-inject:begin --><!-- hexo-inject:end --></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="https://raw.githubusercontent.com/yao2jiang/blog_images/master/bolg_index/new.jpg"></div><div class="author-info__name text-center">Conglei Xu</div><div class="author-info__description text-center"></div><div class="follow-button"><a href="https://github.com/xiaojianhai">Follow me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">18</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">9</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">10</span></a></div></div></div><nav id="nav" style="background-image: url(https://raw.githubusercontent.com/yao2jiang/blog_images/master/bolg_index/header.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Conglei Xu</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">Conglei Xu</div><div id="site-sub-title">Understanding the infinite world within a finite life.</div></div></nav><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2019/08/03/transformer/">transformer</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-08-03</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/paper/">paper</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/paper/">paper</a></span><div class="content"><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>
<!-- hexo-inject:begin --><!-- hexo-inject:end --><h1 id="Attention-is-all-you-need-详解"><a href="#Attention-is-all-you-need-详解" class="headerlink" title="Attention is all you need 详解"></a>Attention is all you need 详解</h1><h2 id="论文提出原因"><a href="#论文提出原因" class="headerlink" title="论文提出原因"></a>论文提出原因</h2><p>1：RNN系列特征提取器</p>
<p>RNN特征提取器基于语言模型</p>
<span>$$$p(t_1,t_2,t_3,....,t_n)=\prod_{k=1}^N{p(t_k|t_1,t_2,t_3,.....t_k-1)} $$$</span><!-- Has MathJax -->
<p>t1,t2,t3,….tn 为一个句子的单词序列，以这种方式提取特征，并行性比较差，因为第k个单词必须在前k-1个单词<br>处理之后才能处理，即使有很多的RNN变体来解决其并行性的问题但是并不能大幅度改变这种并行性，此外这种方式只利用了上文的信息，即使如ELMO里面的操作一样，采取双向进行拼接，但是这种上下文特征进行融合的模式，并不是很理想。</p>
<p>2：CNN系列特征提取器</p>
<p>CNN系列特征提取器，因为没有RNN的这种序列关系的影响，特征提取器速度很快，但是随着句子长度的上升，时间复杂度成指数上涨，对于长句子的依赖提取效果非常差。</p>
<p>因为上述两种特征提取器本省不足，论文提出了基于没有序列操作和卷积操作的Transformer特征提取器，Transformer特征提取器纯基于各个单词注意力机制，他的核心思想就是每一个单词的表示是由其上下文中出现的单词来表示。</p>
<h2 id="Transformer网络结构"><a href="#Transformer网络结构" class="headerlink" title="Transformer网络结构"></a>Transformer网络结构</h2><p>1: 整体结构</p>
<p>  整体由6个相同的encoder和6个相同的decoder堆叠而成，其中每一个encoder又与其对应的decoder连接，整体结构如图：<br><img src="https://raw.githubusercontent.com/xiaojianhai/blog_images/master/pictures/transformer/transformer_1.png" alt="avatar"></p>
<p>2: Encoder</p>
<p>  其中每个Encoder由Multi-head Attention 然后layernorm（数据分布标准化）+残差网络（处理深层网络的一种方式），然后接一个全连接网络，<br>最后对结果进行分布标准化，残差网络，将结果分别传给上层的decoder和对应的Encoder,Encoder 结构如图：<br><img src="https://raw.githubusercontent.com/xiaojianhai/blog_images/master/pictures/transformer/transformer_2.png" alt="avatar"></p>
<p>3: Multi-Head Attention and Scaled Dot-product Attention</p>
<p>  Multi-Head Attention and Scaled Dot-product Attention 如图所示：<br>  <img src="https://raw.githubusercontent.com/xiaojianhai/blog_images/master/pictures/transformer/tranformer_3.png" alt="avatar"><br>  Scaled Dot-product Attention 流程：首先将输入单词进行简单的Embedding 然后嵌入位置，对句子中的每个单词d_word分别乘以三个<br>  矩阵Wq,Wk,Wv,得到三个向量query,key,value,其中Dquery=Dkey,然后利用下面的单词自注意力机制来求每个单词与其上下文之间的联系。<br>  <span>$$$ softmax(\frac{W_{query}^{T}W_{key}}{\sqrt[2]{D_{model}}})*W_{values}$$$</span><!-- Has MathJax --><br>  W_query 为句子中单词的query矩阵，将所具有前后序列性操作的RNN系列替换为各个单词矩阵之间的相乘，给并行性带来了巨大的提高，<br>  同时利用矩阵乘法的优化代码，<br>  同时加快了算法的执行效率。<br>  Multi-Head Attention 公式如下所示：<br>  <span>$$$$ Multi-Head(Q,K,V)=concat(head_1,head_2,head_3,.....,head_h)W^O $$
$$ where head_i=Attention(QW_i^Q,KW_i^K,VW_i^V) $$$$</span><!-- Has MathJax --><br>    Q,K,V 在输入到注意力机制前需要做一个线性变换，所有参数中的所有Q,K,V矩阵分别乘以不同的矩阵。</p>
<p>##网络细节<br>1： 编码位置的方法</p>
<p>  我们的目标是，将最后产生的，word Embedding 是一个与位置具有线性关系的向量，<br>  <span>$$$$ PE(pos,2_i)=\sin(pos/10000^{2_i/d_model})
  PE(pos,2_i+1)=\cos(pos/10000^{2_i/d_model})
$$$$</span><!-- Has MathJax --><br>  通过此公式，每个词向量的各个维度的值与pos的值连接起来，并且PEpos+k能被PEpos通过线性表示出来</p>
<p>2： multi——head策略</p>
<p>  将每个单词映射到几个不同的子空间，在几个不同的子空间中提取特征，同时，模型的复杂度并没有提高，因为<br>  <span>$$$ D_{query}=\frac{D_{model}}{NUM_HEADERS}  $$$</span><!-- Has MathJax --><br>3：残差网络</p>
<p>  论文中Transformer中每层Decoderd都采用了残差连接，避免了网络堆叠带来的梯度消失等问题</p>
<p>##总结<br>  注意力机制策略的核心思想与语言模型类型，每个词的表示都是通过其周围的上下文中的单词来表示，这种直接注意力的方法，让<br>每个单词去直接的与单词进行交互，把位置信息嵌入到embedding中效率很高，同时可以很有效率的利用上文和下文。但是从主观来讲<br>这种嵌入位置信息的方法可能效果不太好，同时因为单词之间采用的是注意力机制，对于句子的处理情况效果也不是很理想。<br>下图是几种，特征提取方式的效率对比图。</p>
<p><img src="https://raw.githubusercontent.com/xiaojianhai/blog_images/master/pictures/transformer/transformer_4.png" alt="avatar"></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/08/01/substring/">substring</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-08-01</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/leetcode/">leetcode</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/algorithm/">algorithm</a></span><div class="content"><h1 id="Longest-Palindromic-Substring"><a href="#Longest-Palindromic-Substring" class="headerlink" title="Longest Palindromic Substring"></a><a href="https://leetcode.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">Longest Palindromic Substring</a></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>‘’’<br>Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.</p>
<p>Example 1:</p>
<p>Input: “babad”<br>Output: “bab”<br>Note: “aba” is also a valid answer.<br>Example 2:</p>
<p>Input: “cbbd”<br>Output: “bb”<br>‘’’</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1：暴力法<br>题目是让求最长的字串，首先暴力法，遍历所有解空间找出所有的字串，然后找出最长的子串比较，时间复杂度分析<br>遍历所有的解空间寻找字串时间复杂度是O(N^2),判断是否为回文串时间复杂度是O(N)，比较字串时间复杂度是O(1)</p>
<p>2:递归法<br>因为是寻找字串的问题，所以当时考虑去用递归去求解，因为这个最长的字串要么在左字串，要么在右字串中，要么<br>横跨左右字串，但是横款左右字串的那种情况不好处理，情况很复杂。</p>
<p>3：动态规划<br>最长字串问题解题时候，想到了用动态规划，首先去寻找递推公式，长字符串和其子字符串之间的最长回文串之间的<br>关系，但是情况很复杂，没能找到正确的递推公式，同时回文串是比较特殊的子问题，因为每个回文串是需要去验证<br>是否为回文串，所以这种动态规划的方式不可行。但是注意到每个回文串是需要验证其真假，每个字串都需要验证<br>，回文串与子回文串之间可以轻松的推出递推公式：以dp[i]<a href="代表字符串中下标i,到j,的字串">j</a> 为例；当且仅<br>当dp[i+1][j-1] 为回文串并且s[i]=s[j]时才成立。</p>
<p>代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type s: str</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        length=len(s)</span><br><span class="line">        ans=<span class="string">''</span></span><br><span class="line">        dp=[[<span class="number">0</span> <span class="keyword">if</span> i!=j <span class="keyword">else</span> <span class="number">1</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(length)]<span class="keyword">for</span> i <span class="keyword">in</span> range(length)]</span><br><span class="line">        <span class="keyword">if</span> length==<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> s</span><br><span class="line">        <span class="comment"># 动态规划的式子中，所有的i，j 是倒序积累的，小的i由大的i计算出</span></span><br><span class="line">        <span class="comment">#所有i的寻找从大到小</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(i,length):</span><br><span class="line">                dp[i][j]=(s[i]==s[j] <span class="keyword">and</span> (j-i&lt;<span class="number">3</span> <span class="keyword">or</span> dp[i+<span class="number">1</span>][j<span class="number">-1</span>]))</span><br><span class="line">                <span class="keyword">if</span> dp[i][j] <span class="keyword">and</span> ( <span class="keyword">not</span> ans <span class="keyword">or</span> len(s[i:j+<span class="number">1</span>])&gt;len(ans)):</span><br><span class="line">                    ans=s[i:j+<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">            </span><br></pre></td></tr></table></figure>


</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/07/23/nlp-conference/">nlp_conference</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-07-23</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/基础知识/">基础知识</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/NLP/">NLP</a></span><div class="content"><h1 id="NLP学术界"><a href="#NLP学术界" class="headerlink" title="NLP学术界"></a>NLP学术界</h1><h2 id="缩写"><a href="#缩写" class="headerlink" title="缩写"></a>缩写</h2><p>自然语言处理NLP(Natural language processing),计算语言学CL(Computational Linguistics)</p>
<p>NLP/CL领域最大的国际专业学会ACL(The Association for Computional Linguistics)</p>
<p>ACL北美分会NAACL(North American Chapter of the ACL)</p>
<p>ACL欧洲分会（Europen Chapter of the ACL)</p>
<p>ACL,EACL,NAACL,举办的会议与学会本身名字相同</p>
<p>ACL下属的兴趣小组；类似总公司下的子公司的概念特殊兴趣小组SIGs(Special interest Groups)</p>
<p>比较著名的兴趣小组：<br>SIGDAT(Linguistic and Data Corpus-based Approches to NLP)</p>
<p>SIGNLL(Natrual language Learining)</p>
<p>SIGDAT举办的会议EMNLP(Conference on Empirical Methonds on Natrual Language Processing)</p>
<p>SIGNLL举办的会议CoNLL(Conference on Natrual Language learning)</p>
<p>学术组织ICCL( internation Committe on Computational Linguistics)</p>
<p>ICCL举办的会议COLING（international conference on computional Linguistics).</p>
<h2 id="各个组织与会议之间的关系"><a href="#各个组织与会议之间的关系" class="headerlink" title="各个组织与会议之间的关系"></a>各个组织与会议之间的关系</h2><ol>
<li>学术组织ACL,ACL的北美分会NAACL，ACL的欧洲分会EACL,他们分别举办的会议：</li>
</ol>
<p>ACL,NAACL,EACL.</p>
<p>同时ACL学术组织创办了ACL的会刊Transactions of ACL(TACL)</p>
<p>ACL学术组织的下属兴趣小组，SIGDAT,SIGNLL,他们分别举办的会议：</p>
<p>SIGDAT:EMNLP，SIGNLL:CoNLL</p>
<p>关于ACL的两个重要链接：</p>
<p><a href="https://aclweb.org/aclwiki/Main_Page" target="_blank" rel="noopener">ACL的wiki页面</a></p>
<p><a href="https://www.aclweb.org/anthology/" target="_blank" rel="noopener">ACL收录的论文</a></p>
<ol start="2">
<li>学术组织ICLL( International Committee on Computational Linguistics),创办的学术会议</li>
</ol>
<p>COLING</p>
<p>总结NLP/CL的高水平成果主要分布在ACL,NAACL,EMNLP,COLING,等几个学术会议</p>
<h2 id="NLP-CL的一些交叉领域"><a href="#NLP-CL的一些交叉领域" class="headerlink" title="NLP/CL的一些交叉领域"></a>NLP/CL的一些交叉领域</h2><p>人工智能国际联合大会IJCAI(International Joint Conferences on Artifical Intelligence)</p>
<p>AAAI(Association for the Advancement of the Artifical Intelligence)</p>
<p>神经信息处理系统大会NIPS(Nerual information Processing Systems)</p>
<h2 id="论文查阅相关"><a href="#论文查阅相关" class="headerlink" title="论文查阅相关"></a>论文查阅相关</h2><p>arXiv:收集物理学，数学计算机科学的网站</p>
<p>中国计算机学会（CCF)：制定了中国计算机学会推荐国际学术会议和期刊目录，基本列出了每个领域的高水平期刊与会议。 </p>
<p>谷歌学术</p>
<h2 id="论文投递相关"><a href="#论文投递相关" class="headerlink" title="论文投递相关"></a>论文投递相关</h2><p>ACL,EMNLP,NAACL,每年举办一次</p>
<p>AAAI 每年举办一次</p>
<p>NIPS 每年举办一次</p>
<p>COLING 每两年举办一次</p>
<p>IJCAI 每两年举办一次</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/07/10/machine-learning-theory/">machine_learning_theory</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-07-10</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/machine-learning/">machine learning</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/theory/">theory</a></span><div class="content"><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>

<h1 id="奥卡姆剃刀原则"><a href="#奥卡姆剃刀原则" class="headerlink" title="奥卡姆剃刀原则"></a>奥卡姆剃刀原则</h1><p>  “Entities should not be multiplied without necessity.”原话来源于维基百科，大意是除非必要不要随意增加实体，更通俗易懂的解释，如果对于同一个现象有两种不同的解释，最有可能正确的解释，即使最简单的解释，即<br>做出最少量假设的解释，在机器学习领域，给定一些训练数据和一个网络架构，有多个模型，多组假设，如果模型的效果差距不大，我们会首先选择假设空间较小的模型，假设空间小意味着网络的参数也更小。</p>
<p>  具体到机器学习的例子，对于连续抛100次硬币，在网络中参数足够多的情况下，我们完全可以拟合出函数M(X)&gt;=2^100我们完全可以拟合出符合数据分布的模型，但这样的模型并没<br>有学习到数据的呈现规律，没有任何意义。如果我们限制假设空间的大小，限制网络的参数，我们是可以拟合出符合数据分布规律的模型，同样的符合数据分布的模型，假设少的有更<br>大可能符合要求.</p>
<p>  机器学习领域中，常用奥卡姆剃刀原则来进行过拟合处理，简单模型是一种参数值分布的熵较低的模型（更不容易过拟合），因此要缓解过拟合，需要限制假设空间的大小，即限制<br>网络的复杂性，具体方法是强制权重采用较小的值，是权重值的分布更规则。通过向网络的损失函数添加与权重较大相关的代价实现。</p>
<blockquote>
<p>L1权重正则化，添加的代价与权重系统的绝对值成正比。<br>L2正则化，添加的代价与权重系数的平方成正比。<br>权重正则化，通过减少损失函数的值从而减少权重的，让部分权重的值很小或者接近零从而减少网络的复杂性。</p>
</blockquote>
<h1 id="天下没有免费的午餐"><a href="#天下没有免费的午餐" class="headerlink" title="天下没有免费的午餐"></a>天下没有免费的午餐</h1><p>  所有学习算法的期望性和随机胡猜差不多，NFL假设所有的问题，所有的机会都相同，但是实际情况不是这样，很多时候我们只关注自己正在试图解决的问题，为其找到合适的解决<br>方案，对于其他问题我们并不关心其好坏，NFL定理最重要的寓意就是脱离具体问题去谈算法的好坏毫无意义，因为考虑所有的潜在问题所有的算法都一样好。</p>
<h1 id="熵"><a href="#熵" class="headerlink" title="熵"></a>熵</h1><p>  在信息论中，熵（entropy)表示随机变量不确定性的度量，设X是一个取有限个值的离散随机变量，其概率分布为<br>  <span>$$$P(X=x_i)=p_i, i=1,2.....,n$$$</span><!-- Has MathJax --><br>  随机变量X的熵定义为：<br>  <span>$$$H(X)=-\sum_{k=1}^np_ilog p_i$$$</span><!-- Has MathJax --><br>  信息的不确定性越大，则H(X)值越大，熵的值也就越大，所含的信息量也就越大。</p>
<p>  条件熵H(Y|X)表示在已知随机变量X的条件下随机变量Y的不确定性，随机变量X给定的条件下随机变量Y的条熵<br> （conditional entropy) H(Y|X),定义为X给定条件下，Y的条件概率分布对X的数学期望。<br> <span>$$$H(Y|X)=\sum_{i}^np_iH(Y|X=x_i)$$$</span><!-- Has MathJax --></p>
 <span>$\\p_i=P(X=x_i）\\,i=1,2......n$</span><!-- Has MathJax -->

<p>  信息增益表示在X确定的情况下，令Y的信息不确定性的下降程度。</p>
<p>  即：具体到机器学习，在特征A对训练集D的信息增益g(D,A)，定义为集合D的经验熵H(D)与特征A给定条件下D的<br>经验条件熵H(D,A):</p>
<span>$$$g(D,A)=H(D)-H(D,A)$$$</span><!-- Has MathJax -->
<p>熵H(Y)与条件熵之间的差H(Y|X)又称作互信息，决策树学习中的信息增益等价于互信息。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/06/19/linux1/">linux1</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-06-19</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/Linux/">Linux</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Linux-命令行/">Linux_命令行</a></span><div class="content"><h1 id="tar命令"><a href="#tar命令" class="headerlink" title="tar命令"></a>tar命令</h1><p>用来解压，打包文件的命令，不能进行压缩操作</p>
<h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><p>tar[必要参数][选择参数][文件]</p>
<h2 id="命令功能"><a href="#命令功能" class="headerlink" title="命令功能"></a>命令功能</h2><p>用来压缩和解压文件，tar本身不具有压缩功能，通过调用压缩功能实现。</p>
<h2 id="必要参数"><a href="#必要参数" class="headerlink" title="必要参数"></a>必要参数</h2><p>-A 新增压缩文件到已存在压缩</p>
<p>-B 设置区块大小</p>
<p>-c 建立新的压缩文件</p>
<p>-x 从压缩文件中提取文件</p>
<p>-t 显示压缩文件的内容</p>
<p>-z 支持gzip解压文件</p>
<p>-j 支持bzip2解压文件</p>
<p>-v 显示操作过程</p>
<p>-k 保留原有文件不覆盖</p>
<p>-W 确认压缩文件正确性</p>
<h2 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h2><p>-b 设置区块数目</p>
<p>-C 切换到指定目录</p>
<p>-f 指定压缩文件</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>解压到特定目录</p>
<p>tar -xzvf .gzip -C target_</p>
<p>将/etc目录下的文件全部打包成为/tmp/etc.tar</p>
<p>tar -cvf /tmp/etc.tar /etc</p>
<p>tar -zcvf /tm[/etc.tar.gz /etc</p>
<p>备份所有文件并且保存权限</p>
<p>tar -zcvpf /tmp/etc.tar.gz /etc</p>
<h1 id="chgrp-chown-chmod"><a href="#chgrp-chown-chmod" class="headerlink" title="chgrp,chown,chmod"></a>chgrp,chown,chmod</h1><h2 id="chgrp"><a href="#chgrp" class="headerlink" title="chgrp"></a>chgrp</h2><p>用来变更文件和目录的群组</p>
<p>chgrp [选项] [组] [文件或目录]</p>
<p>命令参数</p>
<p>-c 当发生改变是输出调试信息</p>
<p>-f 不显示错误信息</p>
<p>-R 递归处理</p>
<p>-v 运行时显示详细的处理信息</p>
<p>chgrp -R bin test6</p>
<p>将test6及其子目录下所有文件和目录群组改为bin</p>
<h2 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h2><p>将指定文件的拥有者改为指定的用户或组，用户可以使用户名或者ID</p>
<p>chown [选项] [所有者：组] 文件</p>
<p>命令参数：</p>
<p>-c 显示更改的部分的信息</p>
<p>-f force忽略错误的信息</p>
<p>-h </p>
<p>-R 递归处理</p>
<p>-v 显示处理信息</p>
<p>双短线：</p>
<p>–help 显示帮助信息</p>
<p>–version 显示版本信息</p>
<p>实例：</p>
<p>将log123的拥有者改为mail,群组改为mail</p>
<p>chown mail:mail log123</p>
<h2 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h2><p>改变文件或目录的权限，当用ls -l 显示文件的详细信息，最左边一列为文件的访问权限</p>
<p>形式如下:-rw-r-r-共10位</p>
<p>第一位指定了文件类型，-为文件，d为目录</p>
<p>2-4, 拥有者的权限</p>
<p>5-7, 组的权限</p>
<p>8-10，为其他的权限</p>
<p>命令格式：</p>
<p>chomd [选项] mode file</p>
<p>命令参数：</p>
<p>-f 错误信息不输出</p>
<p>-R 递归处理</p>
<p>-v 显示详细消息</p>
<p>对象：</p>
<p>u；文件的拥有者</p>
<p>g：文件的群组</p>
<p>o: 其他用户群组</p>
<p>a: 所有的用户和群组</p>
<p>权限：<br>r读：4<br>w写：2<br>x执行：1</p>
<p>实例：</p>
<p>将所有用户增加可执行权限</p>
<p>chmod -f a+x log2013</p>
<p>增加用户执行权限，增加组和其他的写和执行权限</p>
<p>chmod u+x,go+wx log2013 </p>
<p>设置为所有用户读写</p>
<p>chmod 777 log 2013== chmode a+rwx log2012</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/06/04/array/">array</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-06-04</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/algorithm/">algorithm</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/leetcode/">leetcode</a></span><div class="content"><h1 id="Array-篇"><a href="#Array-篇" class="headerlink" title="Array 篇"></a>Array 篇</h1><h2 id="3Sum"><a href="#3Sum" class="headerlink" title="3Sum"></a>3Sum</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.</p>
<p>在整形的数组中，找出所有不相同的元组包含a,b,c 三个数并且三个数和为0。</p>
<p>NOTE:答案中所有的元组必须不同</p>
<p>Example:</p>
<p>Given array nums = [-1, 0, 1, 2, -1, -4],</p>
<p>A solution set is:<br>[<br>  [-1, 0, 1],<br>  [-1, -1, 2]<br>]</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>题目属于找出符合一定规则的数的组合，我们首先要做的是寻找一种策略去寻找符合规则的数，因为初始数据是随机分布的，因此我们需要人为去制造一种分布规律，便于我们对数字的寻找。</p>
<p>首先对原始数组进行排序，依次从数组第一个数为元组第一个数一直到数组倒数第三个数为元组第一个数字，定义两个指针分别指向数组的头尾，然后根据三个数与零的大小不同对指针进行不同的调整策略，当三个数和大于零时说明和过大则右指针左移，相反左指针右移。</p>
<p>具体代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        nums.sort()</span><br><span class="line">        ans=[]</span><br><span class="line">        length=len(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(length<span class="number">-2</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i]&gt;<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> ans</span><br><span class="line">            <span class="keyword">if</span> nums[i]==nums[i<span class="number">-1</span>] <span class="keyword">and</span> i&gt;<span class="number">0</span>:</span><br><span class="line">                <span class="comment">#当相邻的两个数相同则后一个数的解为前一个数解的子集</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment">#利用两个指针策略从左到右，根据不同情况，调节不同的指针移动</span></span><br><span class="line">            l=i+<span class="number">1</span></span><br><span class="line">            r=length<span class="number">-1</span></span><br><span class="line">            <span class="keyword">while</span> l&lt;r:</span><br><span class="line">                <span class="keyword">if</span> nums[i]+nums[l]+nums[r]==<span class="number">0</span>:</span><br><span class="line">                    ans.append([nums[i],nums[l],nums[r]])</span><br><span class="line">                    l+=<span class="number">1</span></span><br><span class="line">                    r-=<span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> r&gt;l <span class="keyword">and</span> nums[r+<span class="number">1</span>]==nums[r]:</span><br><span class="line">                        r-=<span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> r&gt;l <span class="keyword">and</span> nums[l]==nums[l<span class="number">-1</span>]:</span><br><span class="line">                        l+=<span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> nums[i]+nums[l]+nums[r]&gt;<span class="number">0</span>:</span><br><span class="line">                    r-=<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    l+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>








</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/06/04/MLE/">极大释然估计</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-06-04</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/日常积累/">日常积累</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/数学/">数学</a></span><div class="content"><h1 id="极大释然估计"><a href="#极大释然估计" class="headerlink" title="极大释然估计"></a>极大释然估计</h1><h2 id="极大释然估计概念"><a href="#极大释然估计概念" class="headerlink" title="极大释然估计概念"></a>极大释然估计概念</h2><p>在统计学中，maximun likelihood estimation(MLE) 是估计概率模型参数的一种方法。在已知观测的数据的前提下，利用最大化释然函数的方法来确定参数的值。</p>
<p>例子：假设我们对成年雌性企鹅的高度非常感兴趣，但是我们去测量每个成年雌性企鹅的高度是不可能，所以我们需要根据我们观测到的部分样本去估计全部成年雌性企鹅的高度符合的分布，我们假设企鹅的高度符合正态分布（normallly distributed），现在需要解决的问题是，我们需要根据我们手中企鹅的部分样本数据，以及企鹅高度符合的概率模型来确定企鹅高度分布模型的具体参数，对于本例子，需要我们去估计的参数是正态分布的均值（mean) 和 方差<br>（variance)，我们利用极大释然估计（MLE）将mean以及variance作为估计的参数，通过使观测的数据概率最大化来估计参数具体的值。<br>一句话总结：模型已知，模型参数未知，利用样本数据，来估计参数。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2019/06/04/reading/">阅读方法论</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-06-04</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/阅读/">阅读</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/阅读/">阅读</a></span><div class="content"><h1 id="阅读方法论"><a href="#阅读方法论" class="headerlink" title="阅读方法论"></a>阅读方法论</h1><p>法国学者巴斯卡在三百年前就说过：“读得太快或太慢，都一无所获”.<br>在信息化时代，大量的信息，大量的优秀文章，大量的优秀书籍，大量的碎片化时间，我们该如何利用这些大量的时间去高效率的阅读文章书籍，提高阅读效率?掌握阅读的方法，让我们在这短暂的人生中，对这个世界有着更深入的了解吧。</p>
<h2 id="什么是阅读"><a href="#什么是阅读" class="headerlink" title="什么是阅读"></a>什么是阅读</h2><h3 id="阅读的目标"><a href="#阅读的目标" class="headerlink" title="阅读的目标"></a>阅读的目标</h3><p>(1)为获得一定资讯的阅读–这样的阅读，能增加我们的资讯，但对增加我们对现实和规律的理解方面作用会小一些。</p>
<p>(2)为求得理解而读–试着去读一些自己并不了解的东西，通过向更高杆的人去学习，得到全新的更高层次，透过阅读提升自己。</p>
<p>（3）为求娱乐而阅读</p>
<h3 id="主动阅读"><a href="#主动阅读" class="headerlink" title="主动阅读"></a>主动阅读</h3><p>首先对文章或者书籍的层次结构进行了解，心中建立起知识的架构，对于每个篇章，针对篇章的主题，思考自己的问题，带着自己的问题，辩证的去思考书中的知识。—-以目的为导向的阅读方法，当我们心中有自己的目标时，通常更能激起人做事的效率</p>
<h2 id="阅读的层次"><a href="#阅读的层次" class="headerlink" title="阅读的层次"></a>阅读的层次</h2><h3 id="基础阅读"><a href="#基础阅读" class="headerlink" title="基础阅读"></a>基础阅读</h3><p>初步的阅读技巧，逐字逐句理解文章字面上的意思，对其深层次的含义、作者的态度以及作者观点没有深入的思考，停留在知识的表面。</p>
<h3 id="检视阅读"><a href="#检视阅读" class="headerlink" title="检视阅读"></a>检视阅读</h3><p>又称为略读，或者速读，强调在一定的时间内，抓住一本书的重点，是系统阅读的重要方式。第一层阅读关注的是这个句子说的是什么意思而检视阅读是在关注知识的整体架构，例如一本书的整体结构，一本书的重点，阅读前利用检视阅读方法，首先了解知识结构是非常重要的。</p>
<h3 id="分析阅读"><a href="#分析阅读" class="headerlink" title="分析阅读"></a>分析阅读</h3><p>与前两种阅读方式相比，分析阅读的方式更加系统更加复杂化，分析阅读一种全盘的优质的阅读方式，一个分析阅读者一定会对自己所读的东西提出许多系统的问题，分析阅读是一种专注的阅读方式。</p>
<h3 id="主题阅读"><a href="#主题阅读" class="headerlink" title="主题阅读"></a>主题阅读</h3><p>主题阅读是所有的阅读方式中最复杂最系统的一种，我们按照主题去阅读某一类书籍，然后对于这些相同主题的不同书籍进行对比，并列出这些书之间的相关之处。在阅读论文的最好状态应该就是主题阅读与分析阅读相结合的方式。</p>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://raw.githubusercontent.com/yao2jiang/blog_images/master/bolg_index/header.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2023 By Conglei Xu</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://xiaojianhai.github.io/">blog</a>!</div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css"><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="custom_mathjax_source">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end --></body></html>